{
    "contents" : "# A bastardization of the work by the creators of the Mosaic package\n# to allow for a fomula based implementation of Mean Absolute Deviation\n\nMAD.simple <- function(x) {\n  mean.x <- mean(x)\n  n <- length(x)\n  abs.deviation <- abs(x - mean.x)\n  sad <- sum(abs.deviation)\n  mad <- sad / n\n  return(mad)\n}\n\naggregatingFunction1 <- function( fun, input.multiple=FALSE, output.multiple=FALSE, envir=parent.frame() ) {\n  result <- function( x, ..., data, groups=NULL) {\n    orig.call <- match.call()\n    fun.call <- orig.call \n    fun.call[[1]] <- substitute(..fun..)\n    fun.call[[2]] <- substitute(x)\n    \n    # if data is not given, we will try to evaluate fun()\n    missingData <- FALSE  \n    if ( missing(data) ) {\n      missingData <- TRUE\n      data=parent.frame()\n      \n      result <- tryCatch( eval(fun.call, envir=parent.frame()) , \n                          error=function(e) {e} ,\n                          warning=function(w) {w} ) \n      if ( ! inherits(result, \"warning\") && ! inherits(result,\"error\") ) {\n        return(result) \n      }\n    }\n    # either data was specified or fun() generated an error.\n    # so we will generate a new call.\n    maggregate.call <- orig.call  \n    \n    x_name <- substitute(x)\n    if (! .is.formula(x) ) {\n      if ( !missingData) {\n        fun.call[['data']] <- NULL\n      }\n      if (input.multiple) {\n        result <- tryCatch( eval(fun.call, envir=data, enclos=parent.frame()),\n                            error = function(e) {e},\n                            warning = function(w) {w} ) \n        if ( ! inherits(result, \"warning\") && ! inherits(result,\"error\") ) {\n          return(result) \n        }\n      }\n      \n      x <- eval( substitute( \n        mosaic_formula_q( .x, groups=quote(groups)), \n        list(.x=substitute(x) , .g=substitute(groups))\n      ) )\n      \n      if (\"groups\" %in% names(maggregate.call)) maggregate.call[['groups']] <- NULL\n      \n    }\n    # now x is a formula\n    \n    maggregate.call[[1]] <- quote(maggregate)\n    maggregate.call$formula <- x\n    maggregate.call$data <- data \n    maggregate.call$x <- NULL\n    maggregate.call$FUN <- substitute(..fun..)  # keep substitute here or no?\n    maggregate.call$multiple <- output.multiple\n    # print(maggregate.call)\n    return( eval(maggregate.call, envir=envir) )\n  }\n  formals(result) <- c(formals(result), ..fun.. = substitute(fun))\n  return(result)\n}\n\nMAD <- aggregatingFunction1 (MAD.simple)",
    "created" : 1400374690218.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "12|108|71|0|\n",
    "hash" : "2100788890",
    "id" : "E8424556",
    "lastKnownWriteTime" : 1400374886,
    "path" : "~/Dropbox/IDS Curriculum Design/Folder-James/IDS Functions/mad.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}